<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>LimiPush</title> <!-- ToDo -->
    
    <style nonce="/p0blvBXZk3znLeUAqsKBg==">:root {
    /* Consider adjusting this color to match your splash screen! */
    --loading-screen-bg-color: #282828;
}

* {
    margin: 0;
    padding: 0;
    border: 0;
}

html,
body {
    width: 100%;
    height: 100%;
}

.center {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

#loading-screen {
    background-color: var(--loading-screen-bg-color);
}

.spinner {
    width: 128px;
    height: 128px;
    border: 64px solid transparent;
    border-bottom-color: #ececec;
    border-right-color: #b2b2b2;
    border-top-color: #787878;
    border-radius: 50%;
    box-sizing: border-box;
    animation: spin 1.2s linear infinite;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }

    100% {
        transform: rotate(360deg);
    }
}

#bevy {
    /* Hide Bevy app before it loads */
    height: 0;
}
</style>
    <script type="module" nonce="qXb06tlM2UmmTurAgpyuvg==">// taken from https://developer.chrome.com/blog/web-audio-autoplay/#moving-forward
(function () {
    // An array of all contexts to resume on the page
    const audioContextList = [];

    // An array of various user interaction events we should listen for
    const userInputEventNames = [
        'click',
        'contextmenu',
        'auxclick',
        'dblclick',
        'mousedown',
        'mouseup',
        'pointerup',
        'touchend',
        'keydown',
        'keyup',
    ];

    // A proxy object to intercept AudioContexts and
    // add them to the array for tracking and resuming later
    self.AudioContext = new Proxy(self.AudioContext, {
        construct(target, args) {
            const result = new target(...args);
            audioContextList.push(result);
            return result;
        },
    });

    // To resume all AudioContexts being tracked
    function resumeAllContexts(event) {
        let count = 0;

        audioContextList.forEach(context => {
            if (context.state !== 'running') {
                context.resume();
            } else {
                count++;
            }
        });

        // If all the AudioContexts have now resumed then we
        // unbind all the event listeners from the page to prevent
        // unnecessary resume attempts
        if (count == audioContextList.length) {
            userInputEventNames.forEach(eventName => {
                document.removeEventListener(eventName, resumeAllContexts);
            });
        }
    }

    // We bind the resume function for each user interaction
    // event on the page
    userInputEventNames.forEach(eventName => {
        document.addEventListener(eventName, resumeAllContexts);
    });
})();
</script>
    
<script type="module" nonce="KMt7PdjY8hiR/uuepPs3jA==">
import init, * as bindings from './limitpush-f7aaffb76ec9e99f.js';
const wasm = await init('./limitpush-f7aaffb76ec9e99f_bg.wasm');


window.wasmBindings = bindings;


dispatchEvent(new CustomEvent("TrunkApplicationStarted", {detail: {wasm}}));

</script>
<link rel="modulepreload" href="./limitpush-f7aaffb76ec9e99f.js" crossorigin=anonymous><link rel="preload" href="./limitpush-f7aaffb76ec9e99f_bg.wasm" crossorigin=anonymous as="fetch" type="application/wasm"></head>


<body>
    <div id="game" class="center">
        <div id="loading-screen" class="center">
            <span class="spinner"></span>
        </div>

        <canvas id="bevy">
            Javascript and canvas support is required
        </canvas>
    </div>
    <script type="module">
        // Hide loading screen when the game starts.
        const loading_screen = document.getElementById('loading-screen');
        const bevy = document.getElementById('bevy');
        const observer = new MutationObserver(() => {
            if (bevy.height > 1) {
                loading_screen.style.display = 'none';
                observer.disconnect();
            }
        });
        observer.observe(bevy, { attributeFilter: ['height'] });
    </script>
</body>

</html>
